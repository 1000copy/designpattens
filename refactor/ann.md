# 关注成长 新年写给程序员们

## 缘起

几个公司的头脑聚在一起，提到了年会讲什么的问题。我建议不必讲工作和成果，而讲到成长。其中一位问我何为关注成长。我停顿了下，说，我思考下，未来给你答复。

在我看来，关注成长如此的普通也自然，我从未想过要把这个话题深入展开，揉开掰碎的让别人也懂。然而既然被问到了，也就多想了下。如下是我的看法。

## 能力成长和产品成长

首先提到员工成长，在于我看到了一个现象，就是大家日常讨论沟通，更多是谈业务，接到任务，按时完等，这就是产品的成长。然而，产品的成长并不带来员工的成长。另一个可能是大家常常讨论技术，比如说这个业务如何分解到可以管理的程度，如何使用多个类协作完成业务的支撑，如何做代码的重构，以便写出“让人可以理解的代码“，一年后，作为coder的技术小成，这就是能力的成长。

能力的成长，和产品的成长是一对互相制约的因素。产品的成长并不必然带来能力的成长，反过来，能力的成长也并不必然带来产品的成长。最差的就是能力无成长，做的事儿长期也不见效果，因此产品也无成长。当然最好的，就是两者重合起来，彼此推动，烽火连天。我们一年到头，其实工作一直在做，产品一直在发展和成长，而能力却有可能偏废，大家过于花费时间工作写代码。这样的情况，未必都是好事儿。有了能力的提升，可承担更大的项目，完成更高质量的产品，并且得到良性的循环。我的愿望和努力，是在关注成长这个部分的。有很多人关注产品，我关注成长。

## 公司需要和个人需要

现在的情况，是公司的产品逐步的从大型单体应用，走向更多的模块，工具，子系统的协作，各个系统之间必然存在着耦合问题和效率问题，这些引发了新的对程序员的要求，是产品成长的必然需要，而技术上，我们也需要学习到更多的知识，并应用到产品之中，比如更多的设计手法比如类的协同，各种设计模式和套路，更好的设计原则的应用比如SRP，LSP，IoC等等。有了需求，也有了技术的准备才有可能设计出耦合得当，依赖健康，让产品之间不会彼此拖后腿，可以独立发展，适时协作。这给大家提出了新的成长需求。

而成为行业专才，需要做什么，以及怎么做呢。前几年火热，被广泛认同和接受的一个观点，就是10万小时定律，提出者在研究了大部分的行业的顶尖人才后，得出一个结论，无论哪个行业，想要成为顶尖人才，都需要10万小时的刻意练习。这里面大部分人注意到的都是10万小时，也就是专门的11年，而还有一个我特别想要说的，是刻意练习。刻意练习的意思，是我不是因为老板需要，也不是因为工作需要，而是自己需要，创造自己想要做的事儿。我想要学习重构，是为了学习而学习，我想要学习设计模式，是为了学习而学习，我学习它们是不是会因为老板需要，而是我的需要。在我的生命里，我认为我的真正的刻意练习，是一次对HTTP的八个月的学习，当时我不知道我用不用得上，但是我就是对HTTP有好奇心，我恰恰想要做这个事儿，做成了后，我连续写了4本书出来。这个过程，我有在我的书的后记中讲过，有兴趣的可以去看看。成为行业顶尖是极难的事儿，需要天时地利人和等多个方面条件的具备，但是成为公司顶尖就要容易多了。有一个笑话，说的是熊来了，一个人系紧鞋带，准备快跑，另一个人说，你再快也是快不过熊的啊，此人说，我不需要比熊块，我只要比你快就好了。😆。

我观察过业界多年，其中大部分行业人士，都是随波逐流，公司安排做什么就做什么，产品安排什么做什么，多学一点也是不愿意的。什么，做这个需要c++啊，我是c#程序员，我干么做这个。干么要持续集成，我们现在有什么问题。再多的加班，再多的辛苦，倘若不是和刻意练习联系在一起，那么这个时间是无法给你的专才的道路上累加积分的。倘若业务不壮大，个人就止步不前，倘若黑客不来，代码的安全就不会做任何整备。我经常和公司外的行业人士交流，经常发现那些岁月蹉跎，那些干了一辈子，夸夸其谈面向对象的，一上手就是面向过程的代码，完全面向对象的语言，也无法阻止他对面向过程的热情。我也经常发现很多老同行，总是无法跨出代码，以黑盒的角度审视代码，让代码具备可测试性和外在的可理解性。无法以架构的思考去优化代码。手上做了一堆堆的具体工作，脑袋里面没有一点点的抽象思想。

## 成长的主角

关注员工成长的另外一个维度，是员工自身。任何一个工作，任何一场讨论，每个关注自身成长的主体，首要关注的就是自己。以重构讨论会上，首先关注的是自己学到了什么，我可以在什么地方继续去应用学到的技巧，哪怕再小的学到也是值得分享的，哪怕再小的应用也是有价值的。

作为对立面，首要的不需要关注的是，为什么自己当初要这么做，以及为什么我的同事写的代码这么low，为什么我要去帮助他人曲为弥缝。当有人提供重构的支持和分享时，遇到自己的代码，首要的是不要去解释过往，不是判断自己大牛别人胡扯，而是想到对方说到的那些可以为己所用，真诚感谢对方，感谢自己有愿意分享技术的好同事。这样做的最大好处，是自己得到了提升，并且改善和优化了和同事的关系，真诚的欣赏会带来显而易见的好处。自己所处团队，因此在工作中彼此支撑，不至于出现干耗和耻于为伍的团队噩梦。

## 关注专业

作为coder，或者是程序员，工作几年后，就必然面临一个问题，就是如何进阶，如何深造的问题，也从完成工作变成如何写的一首好的代码，如何设计系统，如何打造子系统和模块协作的状况。这里首推一件事情，就是如何提升抽象层度。以写代码为例，我们有很多代码违反了单一职责的设计原则，因此导致抽象程度很低的问题。我在近期做code review，看到了很多代码都存在函数比较大的问题。当我看到函数名和参数清单我就可以看明白的话，那么我们说这个函数抽象的很好，如果抽象的不好，仅仅看函数名称无法预知的功能的话，那么我为了了解功能就必须看函数正文，那么我们说这个函数的抽象级别比较低。此时就表现出一代码的bad smell来，我们可能需要通过Extract Method，来让函数单一职责，让部分代码块下沉到新的函数，让部分代码块上升到新的函数，让临时变量的创建和使用在一起而不是距离很远，如此种种方法，最后的目的达到的就是仅仅看函数就可以知道其功能。那么解决问题的时候，以及添加功能的时候，就可以快速了解到当前代码的功能，而不必为阅读代码花费太多时间了。再进一步，类是比函数更大的构造代码的单元，如果我们看到类名称就知道类的功能的话，那么我们的抽象级别有高了一级，如果我们的模块公开的接口，和子系统公开的api，甚至站点应用公开的api也是可以看到名称即可知晓功能，那么我们的抽象级别就到了子系统一级别。每一次抽象，都带来一次认知上的飞跃，以及站在巨人肩膀上的自由，这样感觉很棒。而要带来这样的效果，必然需要大量的对经典的学习，理论的在应用，比如《重构》我看了7遍，每次看到都会有感觉说原来这个地方，我上次了解的还不够透，其实还有更好的用法等等。我们一直在说抽象，那么代码是抽象的一个维度，还有一个维度，是UML图。作为工业标准的UML其实就是一个比较高的，独立于特定语言的，无需看代码即可了解大局的一种方法。比如我对一个监控系统缺乏了解，我会请一个相关的同事绘制一张图，他也花费了一些时间完成，我们一起在没有看到代码也没有看到UI演示的情况下，了解到了这个系统的框架。比如说我看到了一个系统的UI展示，当我通过UML去理清概念时，我发现半小时左右，我和这个跟同事一起，确定了该系统的类协作骨架。UML确实是一个模块和子系统级别的很好的协作工具。而这个使用UML表达和协作的技能也是需要多年的学习和实践的。对于专业的技术，可怕的不是你现在不会，而是你工作多年后，依然不会。没有自己的强力的意愿，缺乏前辈的指引，陷入日常工作和生活的泥沼，完全可能在一个行业内工作多年，却根本不能成为一个令人尊重的专业工程师，稍微脱离一点点的编码实现业务功能之外的技能就立刻显出小白的本质，这是真正危险的。我们现在在做的重构，未来在做的设计都是让大家有机会常常和同事一起，做技术实现和抽象设计交流的可能。我们常常可以在一起谈到当前代码的bad smells，诸如散弹枪，基本类型偏执等，也会常常一起谈到重构手法，如replace temp by query，extract method等技巧，可以谈论优秀的算法和良好的设计套路。这是一个很好的开始，而每项微小或者巨大的成就都来自于个人的强大意愿和反反复复得到实践操作。


## 过程如何变成对象

要是你真的热血沸腾，我告诉你要成为专家，得需要专家的养料。当前我们的系统中，存在这样的大量的养料。比如“过于长的函数名”这个坏味道，我看到了很多，比如说保存一个实体，做法是

	saveEntityXXX()

这样的命名，其实就是一个动词+名词的结构，你需要说它是做什么的，以及对谁做，说明的是一个动作，因此是面向过程的一种编码套路。很多人工作多年，都是这个套路，但是既然面向对象是工业标准，是主流的业界套路，那么一定是值得学习和反复玩味的。其实面向对象技术思维稍微的调整一下，把一个动作+名称，调成为一个名称+动作。就是说此案例的函数名称，可以改成：

    entityXXX.save()

是不是函数名称立刻就变得非常简短了？所以只要函数名过程，就需要检视自己的面向过程套路是否可以优化的。

相应的，我看到了很多函数参数极长的，比如11个参数等等。是的，这也是一种面向过程的套路，两个或者多个函数直接协作，如果不用全局变量就得使用参数，随着功能的增加，函数参数考虑更多的情况，自然会越来越长。可是如果采用了对象的封装，此时你的工具立刻就从单一的函数参数，变成还可以使用类数据成员了。有些参数如果在多个函数使用，那么完全可能使用数据成员来传递，参数清单自然减少。你的协作工具箱里面的工具又多了意向了。依然以代码为例，两个函数a，b，传递参数5个。代码如下：

	class Foo{
		a(){
			b(a1,a2,a3,a4,a5)
		}
		b(a1,a2,a3,a4,a5){

		}
	}
如果使用OO的话，理论上，而已这样

	class Foo{
		constructor{
			this.a1 =  null
			this.a2 =  null
			this.a3 =  null
			this.a4 =  null
			this.a5 =  null
		}

		a(){
			b()
		}
		b(){
			a1 = this.a1
			a2 = this.a2
			a3 = this.a3
			a4 = this.a4
			a5 = this.a5
		}	
	}

当然，这里讲的是一种极限的情况，你不必所有的参数都放到数据成员内，表意第一，技术第二。

这样的代码极多，这就给我们的专业程序员成长提供了土壤，每次对代码的一次重构，都是自己走上专业素养的一次机会。不要嫌弃你的团队的代码质量不够优良，这正是给予你的机会。不要埋怨别人乱写，不要埋怨自己为何还是不够专业。倘若专业的事儿可以一步登天，那么和买红薯有什么区别？所谓艺高人胆大，每次困难也都是一次机会而已。以重构为例，坏味道数十个，重构套路上百，认真学习，反复操练，一年后再来看，轻舟已过万重山。


## 略高标准

我见过80K的单函数代码，一个巨型的switch，没加一个单据就加入一个巨大的分支，年积月累，每个程序员都让他变得更差。有人说，没办法的，不敢改，因为改一点就可能出错的。我想说的是，起码不要因为你的个人工作，给它在继续添加负担。对于既有的代码，确实有着极为巨大的惯性。比如一个80K的单函数代码，其中每次加入一单据类型就让此代码继续膨胀一次。当然是违背SRP，违背开闭原则的。最轻松的方法，是如何大家厌恶的一样，继续加上一个分支，继续让代码膨胀。不那么轻松，但是不会继续增大惯性的，是即进入此函数，立即判断是新单据立即转向到一个新的函数。对于巨大的Switch case语句也照此办理。这样你就在优化代码上走出了第一步，这个第一步，意义非凡，意味着你有办法让一直惯性行走的巨兽变得不再长大。在新的小天地里面，你有了发现巨兽减肥瘦身的经验，你会在未来获得更多经验，真的有一天，你信心满满的，开始真的动手，点点滴滴的干掉这个巨兽。让它成就你的思维，从面向过程到面向对象，你干掉了巨兽，你自己成为经验丰富的专家，成为令人尊敬的行家里手。

再者，相信代码超过50行就是有坏味道的。没有理由，只要相信。一旦你真的相信，你才会想办法去解决它，想认识可以帮助自己解决问题的人，然后就可以一步进入抽象的世界。为此，我的建议是：

1. 首先，相信行业顶级人物的判断，而不是你的判断。
2. 首先，不要让工具给你所用，让你为工具所用。
3. 首先，让你自己学会盲从，然后在发展你的自由意志。
4. 首先，让你相信工具，而不是急着学习思想。
5. 首先，相信OO就是最好的，是工业界的标准，是经过大多数高手的选择，所以才得以发展起来的，而不是自己玩自己的面向过程这套过于朴素的东西
6. 首先，相信学习设计，就得是学习UML。我反对什么你知道能够表达思想，什么图都可以，不一定要UML图的这样的看起来有道理的思想。我也反对什么每个人都有模式，设计模式没有什么大不了的之类的思想。

## 书单

是的，看再多励志，最好的成长，依然是看书。这个最为自主，也最容易和顶尖人士对话。

### 重构

重构的书，也有几本，不太多，最为值得看的就是《重构：改善既有代码的设计》，这本书我看了几遍，看了几年，经常翻阅，经常实践。每次都是开卷有益。其中的代码，我差不多都细致的读过，有些我敲过几遍。有了重构，曾经让我困扰的遗留代码，称为我打通coder关口的一套套关卡，过关越来越顺。数十种坏味道和重构手法熟捻于胸。几年后，我写了4本电子小册，我摸着这本重构的书，突然想到清晰，“什么叫做行业顶尖人才”，为什么MF是，而我不是。为什么MF写一本书，有那么多人缘帮助和支持他，而我就是做不到。

### 设计模式

设计模式的书，真的不少，我看了N本。其中还是《设计模式》这本书看起来最好。然而，设计模式这本书高度抽象，并且有些术语，因为比较早期创造，容易误解。并且本来配置的代码光盘，早就随风而逝了，早就没有跟着书走了，因此，阅读代码片段也有难度。


### UML

这类书还是比较多，比如《UML精粹》，看起来不费劲，而且会有MF自己的一些思想和日常实践的选择在里面，相当不错的一本小书。

风物长宜放眼量。与诸君共勉。













